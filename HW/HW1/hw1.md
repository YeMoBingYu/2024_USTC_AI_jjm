# HW1
## PB21111686_赵卓
### 3.6
- $(a).$
  $状态:A(s_1,s_2,\dots ,s_n)(s_1,s_2,\dots ,s_n分别表示n个地区着色情况,取值0-4分别对应未着色和四种颜色)$
  $初始状态:A(0,\dots , 0)$
  $行动:Change(k,0-4)(表示改变第k个地区当前着色情况到0-4中一种)$
  $转移模型:Result(A_{s_k=k},Change(k,color))=A_{s_k=color}$
  $目标测试:检测是否s_{k,1\le k \le n}\ne0且任何两个相邻的地区i,j满足s_i\ne s_j$
  $路径消耗：一次Change耗散值为1$
<br>

- $(b).$
  $状态:A(s,h)(s表示箱子的堆叠情况,0表示未堆叠,1表示堆叠;h表示猴子的高度)$
  $初始状态：A(0,3)$
  $行动:up(爬上箱子),down(爬下箱子),increase(将箱子堆叠)$
  $转移模型:$
  $Result(A(0/1,h),up)=A(0,h+3/h+6)$
  $Result(A(0/1,h),down)=A(0,h-3/h-6)$
  $Result(A(0,h),increase)=A(1,h)$
  $目标测试:检测是否h\ge8$
  $路径消耗:up,down,increase耗散值都为1$
<br>

- $(d).$
  $状态:A(s_1,s_2,s_3)(s_1,s_2,s_3分别表示三个水壶中水的容量,s_1\le12,s_2\le 8,s_3\le 3)$
  $初始状态:A(0,0,0)$
  $行动:move(i,j,k)(从第i个水壶中倒出k加仑水到第j个水壶中,i=0表示向第j个水壶倒k加仑水,j=0表示从第i个水壶向地面倒k加仑水)$
  $转移模型:$
  $Result(A_{s_j=j},move(0,j,k))=A_{s_j=j+k}$
  $Result(A_{s_i=i},move(i,0,k))=A_{s_i=i-k}$
  $Result(A_{s_i=i,s_j=j},move(i,j,k))(i,j\ne0)=A_{s_i=i-k,s_j=j+k}$
  $目标测试:检测是否\exist k,s_k=1$
  $路径消耗:move耗散值为k。$

### 3.7
- $(1).$
  $状态:A(s_1,s_2,b)(s_1,s_2表示起点的传教士和野人人数,b取值0,1表示船在起点或者对岸)$
  $初始状态:A(3,3,0)$
  $行动:move(i,j,b)(move表示船载人移动,i,j表示船上的传教士和野人人数,b取值0,1表示船从起点和对岸出发)$
  $转移模型:$
  $Result(A(s_1,s_2,0),move(i,j,0))=A(s_1-i,s_2-j,1)$
  $Result(A(s_1,s_2,1),move(i,j,i))=A(s_1+i,s_2+j,0)$
  $目标测试:检测是否s_1=0,s_2=0,b=1$
  $路径消耗:move耗散值为1$
  $状态空间图如下:$
  ```mermaid
  graph LR;
  1((A（3,3,0）)) -- move(0,1,0) --> 2((A（3,2,1）))
  2 -- move(0,1,1) --> 1
  1 -- move(1,1,0) --> 3((A（2,2,1）))
  1 -- move(0,2,0) --> 5
  3 -- move(1,1,1) --> 1
  3 -- move(1,0,1) --> 4((A（3,2,0）))
  4 -- move(0,1,0) --> 5((A（3,1,1）))
  5 -- move(0,2,1) --> 1
  5 -- move(0,1,1) --> 4
  4 -- move(0,2,0) --> 6((A（3,0,1）))
  4 -- move(1,0,0) --> 3
  6 -- move(0,2,1) --> 4
  6 -- move(0,1,1) --> 7((A（3,1,0）))
  7 -- move(0,1,0) --> 6
  7 -- move(2,0,0) --> 8((A（1,1,1）))
  8 -- move(2,0,1) --> 7
  8 -- move(1,1,1) --> 9((A（2,2,0）))
  9 -- move(1,1,0) --> 8
  9 -- move(2,0,0) --> 10((A（0,2,1）))
  10 -- move(2,0,1) --> 9
  10 -- move(0,1,1) --> 11((A（0,3,0）))
  11 -- move(0,1,0) --> 10
  11 -- move(0,2,0) --> 12((A（0,1,1）))
  12 -- move(0,2,1) --> 11
  12 -- move(0,1,1) --> 13((A（0,2,0）))
  13 -- move(0,1,0) --> 12
  13 -- move(0,2,0) --> 14((A（0,0,1）))
  14 -- move(0,2,1) --> 13
  ```
  <br>

- $(2).$
  $可采用深度优先搜索，直到在状态空间中找到目标状态。$
  $在搜索过程中，应该检测重复状态避免无效搜索和死循环。$
  <br>

- $(3).$
  $尽管看起来形式化空间简单，但是在得到形式化空间的过程中很困难。$
  $主要原因在于：$
  $1.约束条件的复杂性：虽然状态简单，但是约束条件却让每一个动作都要仔细考虑避免违规。$
  $2.操作的相互依赖：每一步动作都会影响下一步的动作，这使得问题步骤必须考虑全面。$
  $3.状态空间的增长：随着数量的增大，状态空间也会不断增大。$